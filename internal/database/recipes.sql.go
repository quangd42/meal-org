// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: recipes.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (
  id,
  created_at,
  updated_at,
  name,
  description,
  external_url,
  user_id,
  servings,
  yield,
  cook_time_in_minutes,
  notes
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, created_at, updated_at, external_url, name, description, servings, yield, cook_time_in_minutes, notes, user_id
`

type CreateRecipeParams struct {
	ID                uuid.UUID `json:"id"`
	CreatedAt         time.Time `json:"created_at"`
	UpdatedAt         time.Time `json:"updated_at"`
	Name              string    `json:"name"`
	Description       *string   `json:"description"`
	ExternalUrl       *string   `json:"external_url"`
	UserID            uuid.UUID `json:"user_id"`
	Servings          int32     `json:"servings"`
	Yield             *string   `json:"yield"`
	CookTimeInMinutes int32     `json:"cook_time_in_minutes"`
	Notes             *string   `json:"notes"`
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.Description,
		arg.ExternalUrl,
		arg.UserID,
		arg.Servings,
		arg.Yield,
		arg.CookTimeInMinutes,
		arg.Notes,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalUrl,
		&i.Name,
		&i.Description,
		&i.Servings,
		&i.Yield,
		&i.CookTimeInMinutes,
		&i.Notes,
		&i.UserID,
	)
	return i, err
}

const deleteRecipe = `-- name: DeleteRecipe :exec
DELETE FROM recipes
WHERE id = $1
`

func (q *Queries) DeleteRecipe(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRecipe, id)
	return err
}

const getRecipeByID = `-- name: GetRecipeByID :one
SELECT id, created_at, updated_at, external_url, name, description, servings, yield, cook_time_in_minutes, notes, user_id FROM recipes
WHERE id = $1
`

func (q *Queries) GetRecipeByID(ctx context.Context, id uuid.UUID) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipeByID, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalUrl,
		&i.Name,
		&i.Description,
		&i.Servings,
		&i.Yield,
		&i.CookTimeInMinutes,
		&i.Notes,
		&i.UserID,
	)
	return i, err
}

const listRecipesByUserID = `-- name: ListRecipesByUserID :many
SELECT id, created_at, updated_at, external_url, name, description, servings, yield, cook_time_in_minutes, notes, user_id
FROM recipes
WHERE user_id = $1
ORDER BY name
LIMIT
  $2
  OFFSET $3
`

type ListRecipesByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListRecipesByUserID(ctx context.Context, arg ListRecipesByUserIDParams) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listRecipesByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExternalUrl,
			&i.Name,
			&i.Description,
			&i.Servings,
			&i.Yield,
			&i.CookTimeInMinutes,
			&i.Notes,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipesWithCuisinesByUserID = `-- name: ListRecipesWithCuisinesByUserID :many
SELECT
  r.id, r.created_at, r.updated_at, r.external_url, r.name, r.description, r.servings, r.yield, r.cook_time_in_minutes, r.notes, r.user_id,
  string_agg(c.name, ', ') AS cuisines
FROM
  recipes r
LEFT JOIN
  recipe_cuisine rc ON r.id = rc.recipe_id
LEFT JOIN
  cuisines c ON rc.cuisine_id = c.id
WHERE
  r.user_id = $1
GROUP BY
  r.id
LIMIT
  $2
  OFFSET $3
`

type ListRecipesWithCuisinesByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListRecipesWithCuisinesByUserIDRow struct {
	ID                uuid.UUID `json:"id"`
	CreatedAt         time.Time `json:"created_at"`
	UpdatedAt         time.Time `json:"updated_at"`
	ExternalUrl       *string   `json:"external_url"`
	Name              string    `json:"name"`
	Description       *string   `json:"description"`
	Servings          int32     `json:"servings"`
	Yield             *string   `json:"yield"`
	CookTimeInMinutes int32     `json:"cook_time_in_minutes"`
	Notes             *string   `json:"notes"`
	UserID            uuid.UUID `json:"user_id"`
	Cuisines          []byte    `json:"cuisines"`
}

func (q *Queries) ListRecipesWithCuisinesByUserID(ctx context.Context, arg ListRecipesWithCuisinesByUserIDParams) ([]ListRecipesWithCuisinesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listRecipesWithCuisinesByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecipesWithCuisinesByUserIDRow
	for rows.Next() {
		var i ListRecipesWithCuisinesByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExternalUrl,
			&i.Name,
			&i.Description,
			&i.Servings,
			&i.Yield,
			&i.CookTimeInMinutes,
			&i.Notes,
			&i.UserID,
			&i.Cuisines,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipeByID = `-- name: UpdateRecipeByID :one
UPDATE recipes
SET
  name = $2,
  external_url = $3,
  description = $9,
  updated_at = $4,
  servings = $5,
  yield = $6,
  cook_time_in_minutes = $7,
  notes = $8
WHERE id = $1
RETURNING id, created_at, updated_at, external_url, name, description, servings, yield, cook_time_in_minutes, notes, user_id
`

type UpdateRecipeByIDParams struct {
	ID                uuid.UUID `json:"id"`
	Name              string    `json:"name"`
	ExternalUrl       *string   `json:"external_url"`
	UpdatedAt         time.Time `json:"updated_at"`
	Servings          int32     `json:"servings"`
	Yield             *string   `json:"yield"`
	CookTimeInMinutes int32     `json:"cook_time_in_minutes"`
	Notes             *string   `json:"notes"`
	Description       *string   `json:"description"`
}

func (q *Queries) UpdateRecipeByID(ctx context.Context, arg UpdateRecipeByIDParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, updateRecipeByID,
		arg.ID,
		arg.Name,
		arg.ExternalUrl,
		arg.UpdatedAt,
		arg.Servings,
		arg.Yield,
		arg.CookTimeInMinutes,
		arg.Notes,
		arg.Description,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalUrl,
		&i.Name,
		&i.Description,
		&i.Servings,
		&i.Yield,
		&i.CookTimeInMinutes,
		&i.Notes,
		&i.UserID,
	)
	return i, err
}
